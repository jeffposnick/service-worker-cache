<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-signals/core-signals.html">

<!--
An experimental Polymer element represents a cachable resource, to be used in conjunction with a [`<service-worker-cache>`](#service-worker-cache).

This element communicates with [`<service-worker-cache>`](#service-worker-cache) via [`<core-signals>`](https://github.com/Polymer/core-signals), so there doesn't need
to be a specific DOM relationship between the two.

You can learn more about service workers at https://github.com/slightlyoff/ServiceWorker/

Currently, this requires Google Chrome canary with the experimental web features flag turned on.

You can learn more about browser support at https://jakearchibald.github.io/isserviceworkerready/

##### Example

    <service-worker-cachable-resource
      relativeUrl="path/to/file"
      auto
      cached="{{isFileCached}}">
    </service-worker-cachable-resource>

This will automatically cache the resource at `"path/to/file"` and publish the cached state via the `isFileCached` variable.

@element service-worker-cachable-resource
@blurb An experimental Polymer element represents a cachable resource.
@status alpha
@homepage http://jeffposnick.github.io/service-worker-cache
-->
<polymer-element name="service-worker-cacheable-resource" attributes="relativeUrl cached auto">
  <template>
    <core-signals on-core-signal-service-worker-response="{{handleServiceWorkerResponse}}"></core-signals>
  </template>

  <script>
    Polymer('service-worker-cacheable-resource', {
      /**
       * The `relativeUrl` of the resource to cache. This attribute is required.
       *
       * @property relativeUrl
       * @type string
       */
      relativeUrl: '',

      /**
       * Indicates whether the resource is currently present in the cache.
       *
       * @property cached
       * @type bool
       * @default false
       */
      cached: false,

      /**
       * Indicates whether the resource is automatically cached.
       *
       * If `false`, the resource can be manually cached via the `cache()` method.
       *
       * Defaults to `false`.
       *
       * @property auto
       * @type bool
       * @default false
       */
      auto: false,

      relativeUrlChanged: function() {
        if (this.auto) {
          this.cache();
        } else {
          this.status();
        }
      },

      autoChanged: function() {
        if (this.auto) {
          this.cache();
        }
      },

      _fireSignal: function(signalName) {
        if (this.relativeUrl) {
          this.asyncFire('core-signal', {
            name: signalName,
            data: this.relativeUrl
          });
        }
      },

      /**
       * The `cache` method caches the resource identified by the `relativeUrl` property.
       *
       * @method cache
       */
      cache: function() {
        this._fireSignal('service-worker-cache-request');
      },

      /**
       * The `uncache` method removes the resource identified by the `relativeUrl` property from the cache.
       *
       * @method uncache
       */
      uncache: function() {
        this._fireSignal('service-worker-uncache-request');
      },

      /**
       * The `status` method determines whether a given resource, indentified by the `relativeUrl` property, is already cached.
       *
       * @method status
       */
      status: function() {
        this._fireSignal('service-worker-status-request');
      },

      handleServiceWorkerResponse: function(e) {
        if (e.detail.relativeUrl == this.relativeUrl) {
          this.cached = e.detail.cached;
        }
      }
    });
  </script>
</polymer-element>
